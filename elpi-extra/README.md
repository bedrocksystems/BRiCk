# Extension of the Elpi standard library

Synopsis:
```coq
Require Import bedrock.elpi.extra.extra.
(* ... *)
Elpi Accumulate File extra.{Program,Tactic,Command}.
```
The three databases account for the _nature_ of the Elpi program being accumulated.
Only commands, for example, can parse attributes, and that's reflected in the types, terms, and predicates available from the Elpi command template and database `extra.Command`.

All three databases support Coq's half-baked phase distinction (_e.g.,_ only interp actions fully support Coq terms while only synterp actions change Coq's module structure).
Use attributes `#[interp]`, `#[synterp]`, `#[phase="both"]` on `Elpi Accumulate`.



## Namespaces

We put everything in the following Elpi namespaces.

<!-- `Edit /BEGIN/+-;/END/-+<./grid.ml extra` # ignore warnings about `extra/derive/*.elpi` -->
<!-- BEGIN generated by `./grid.ml extra` -->
* `attr`, Command only, both phases: [Command/both](extra/Command/both/attr.elpi),
* `coq`, any prelude, both phases: [Program/both](extra/Program/both/coq.elpi), [Program/interp](extra/Program/interp/coq.elpi), [TacticCommand/interp](extra/TacticCommand/interp/coq.elpi),
* `diag`, any prelude, both phases: [Program/both](extra/Program/both/diag.elpi), [Program/interp](extra/Program/interp/diag.elpi),
* `elpi`, any prelude, both phases: [Program/both](extra/Program/both/elpi.elpi),
* `ident`, any prelude, interp only: [Program/interp](extra/Program/interp/ident.elpi),
* `int`, any prelude, interp only: [Program/interp](extra/Program/interp/int.elpi),
* `list`, any prelude, both phases: [Program/both](extra/Program/both/list.elpi), [Program/interp](extra/Program/interp/list.elpi),
* `option`, any prelude, both phases: [Program/both](extra/Program/both/option.elpi), [Program/interp](extra/Program/interp/option.elpi),
* `pair`, any prelude, interp only: [Program/interp](extra/Program/interp/pair.elpi),
<!-- END generated -->



***Note.***
In part, this library relates Elpi types and terms to Gallina types and terms.
We address the same problem---in much the same way---in our Ltac2 library ltac2-extra.
The Elpi namespaces `ident`, `int`, `list`, and `option` defined here, for example, track modules `Ltac2.{Ident, Int, List, Option}` from ltac2-extra.
Please try to be consistent!



## Example

Example:
```coq
Require Import bedrock.elpi.extra.extra.

Elpi Command example.
Elpi Accumulate File extra.Command.
```




## Databases, not files

We package up the library as databases rather than files because accumulating a given database into an Elpi program may be idempotent while accumulating files certainly is not (see [coq-elpi#627](https://github.com/LPCIC/coq-elpi/issues/627)).

Idempotence matters because duplicate clauses may lead to hard-to-diagnose operational errors (_e.g.,_ backtracking to (a copy of) the same code).

Less important, database names need not vary with Coq's synterp, interp phase distinction and databases (presumably) store compiled code rather than source code.


## Manual Linking

Our Elpi code uses `lib:name` to resolve Coq paths previously [registered with `Rocqlib`](https://coq.inria.fr/doc/V8.19.0/refman/proof-engine/vernacular-commands.html#coq:cmd.Register).
The command `Elpi Accumulate` panics on unresolved names.

Rather than register everything we need, we reuse names registered by Coq's standard library; for example, we require `Coq.Numbers.BinNums` because it has the effect of registering names for `positive`, `N`, and `Z` (and their constructors).

Elpi should improve.

***Note.***
`Rocqlib` names matter when viewing elpi-extra as a collection of disembodied Elpi _files_ rather than as an Elpi _database_.
Using elpi-extra as a bunch of files is not supported due to [coq-elpi#627](https://github.com/LPCIC/coq-elpi/issues/627), and probably should not be supported in any case.



## Dependencies

There seems to be no nice way to tell dune about dependencies between Elpi files triggered by Elpi's `accumulate` directive.
(Neither dune nor coqdep scans Elpi files for depenencies.)

As a stopgap, we ask dune to generate Elpi files from templates, adding comments containing hashes of their (manually listed) dependencies.
This forces clients to recompile when those dependencies change.
